{"version":3,"file":"commonHelpers.js","sources":["../src/js/algorithms/branchesAndBounds/matrixReduction.js","../src/js/algorithms/branchesAndBounds/penalties.js","../src/js/algorithms/branchesAndBounds/etapThree.js","../src/js/algorithms/branchesAndBounds/branchesAndBounds.js"],"sourcesContent":["// Знаходження мінімальних елементів по стовпцях\nexport function minFromColumns(matrix) {\n  const mins = [];\n  const columns = Object.keys(matrix[0]);\n\n  columns.forEach(column => {\n    const columnValues = matrix.map(row => row[column]);\n    mins[column] = Math.min(...columnValues);\n  });\n\n  return mins;\n}\n\n// Віднімання мінімумів по стовпцях\nexport function subEveryColumn(matrix) {\n  const mins = minFromColumns(matrix);\n\n  return matrix.map(row =>\n    row.map((value, j) => {\n      if (mins[j] === Infinity) {\n        return value;\n      } else {\n        return value - mins[j];\n      }\n    })\n  );\n}\n\n// var-1 columns\n// export function subEveryColumn(matrix, newMinBorderCols) {\n//   const mins = minFromColumns(matrix);\n//   newMinBorderCols += Object.values(mins).reduce((acc, curr) => acc + curr, 0);\n\n//   const newMatrix = matrix.map((row, i) =>\n//     row.map((value, j) => value - mins[j])\n//   );\n\n//   return { matrix: newMatrix, newMinBorderCols };\n// }\n\n// var-2 columns\n// export function subEveryColumn(matrix, newMinBorderCols) {\n//   const mins = minFromColumns(matrix);\n\n//   const newMatrix = matrix.map(row =>\n//     row.map((value, j) => {\n//       if (mins[j] === Infinity) {\n//         return value;\n//       } else {\n//         return value - mins[j];\n//       }\n//     })\n//   );\n\n//   const validMins = Object.values(mins).filter(min => min !== Infinity);\n//   newMinBorderCols += validMins.reduce((acc, curr) => acc + curr, 0);\n\n//   return { matrix: newMatrix, newMinBorderCols };\n// }\n\n// Знаходження мінімальних елементів по рядкам\nexport function minFromRows(matrix) {\n  return matrix.map(row => Math.min(...row));\n}\n\n// Віднімання мінімумів по рядках\n// var3\nexport function subEveryRow(matrix) {\n  const mins = minFromRows(matrix);\n\n  return matrix.map((row, i) => {\n    if (mins[i] === Infinity) {\n      return row;\n    } else {\n      return row.map(value => value - mins[i]);\n    }\n  });\n}\n\n// var1\n// export function subEveryRow(matrix, newMinBorderRows) {\n//   const mins = minFromRows(matrix);\n//   newMinBorderRows += mins.reduce((acc, curr) => acc + curr, 0);\n\n//   const newMatrix = matrix.map((row, i) =>\n//     row.map((value, j) => value - mins[i])\n//   );\n\n//   return { matrix: newMatrix, newMinBorderRows };\n// }\n\n// var2 check Infinity\n// export function subEveryRow(matrix, newMinBorderRows) {\n//   const mins = minFromRows(matrix);\n\n//   const newMatrix = matrix.map((row, i) => {\n//     if (mins[i] === Infinity) {\n//       return row;\n//     } else {\n//       return row.map(value => value - mins[i]);\n//     }\n//   });\n\n//   const validMins = mins.filter(min => min !== Infinity);\n//   newMinBorderRows += validMins.reduce((acc, curr) => acc + curr, 0);\n\n//   return { matrix: newMatrix, newMinBorderRows };\n// }\n\n// Сума констант зведення\nexport function sumOfReducedElements(minsByCols, minsByRows) {\n  let totalSum = 0;\n  for (let i = 0; i < minsByCols.length; i += 1) {\n    totalSum += minsByCols[i];\n  }\n\n  for (let i = 0; i < minsByRows.length; i += 1) {\n    totalSum += minsByRows[i];\n  }\n\n  return totalSum;\n}\n\n// export function sumMins(matrix) {\n//   let sum = 0;\n\n//   const mins = minFromRows(matrix);\n//   const validMins = mins.filter(min => min !== Infinity);\n//   sum += validMins.reduce((acc, curr) => acc + curr, 0);\n\n//   const colsMins = minFromColumns(matrix);\n//   const validColsMins = Object.values(colsMins).filter(min => min !== Infinity);\n//   sum += validColsMins.reduce((acc, curr) => acc + curr, 0);\n\n//   return sum;\n// }\n\nexport function sumOfMins(minFromRows, minFromColumns) {\n  const sumValidMins = mins =>\n    mins.filter(min => min !== Infinity).reduce((acc, curr) => acc + curr, 0);\n\n  // const sumRows = sumValidMins(minFromRows(matrix));\n  // const sumCols = sumValidMins(Object.values(minFromColumns(matrix)));\n\n  const sumRows = sumValidMins(minFromRows);\n  const sumCols = sumValidMins(minFromColumns);\n\n  return sumRows + sumCols;\n}\n","/**\n * Обчислює штраф для кожного нуля в матриці\n * @param {number[][]} matrix - Вхідна матриця\n * @return {number[][]} - Матриця штрафів\n */\nexport function calculatePenalties(matrix) {\n  const penalties = []; // масив для матриці штрафів\n\n  // Проходимося по кожному рядку матриці\n  for (let i = 0; i < matrix.length; i += 1) {\n    penalties[i] = []; // масив для рядка матриці штрафів\n\n    // Проходимося по кожному елементу у рядку\n    for (let j = 0; j < matrix[i].length; j += 1) {\n      // Якщо знаходимо нуль\n      if (matrix[i][j] === 0) {\n        penalties[i][j] = calculatePenaltyForRowAndColumn(matrix, i, j);\n      } else {\n        penalties[i][j] = null; // Штраф не обчислюється для не-нульових елементів\n      }\n    }\n  }\n\n  return penalties;\n}\n\n/**\n * Обчислює штраф для нуля у вказаному рядку та стовпці\n * @param {number[][]} matrix - Вхідна матриця\n * @param {number} row - Номер рядка\n * @param {number} column - Номер стовпця\n * @return {number} - Штраф для нуля\n */\nexport function calculatePenaltyForRowAndColumn(matrix, row, column) {\n  // Фільтруємо значення рядка, виключаючи поточний нуль та Infinity\n  const rowValues = matrix[row].filter(\n    (value, index) => index !== column && value !== Infinity\n  );\n\n  // Фільтруємо значення стовпця, виключаючи Infinity\n  const columnValues = matrix\n    .map(row => row[column])\n    .filter(value => value !== Infinity);\n\n  // // Знаходимо мінімальне значення рядка, якщо є такі значення\n  // const minRowValue = rowValues.length > 0 ? Math.min(...rowValues) : 0;\n\n  // // Знаходимо мінімальне значення стовпця, якщо є такі значення\n  // const minColumnValue =\n  //   columnValues.length > 0 ? Math.min(...columnValues) : 0;\n\n  // Знаходимо мінімальне значення рядка, використовуючи цикл\n  let minRowValue = rowValues[0];\n  for (let i = 1; i < rowValues.length; i++) {\n    if (rowValues[i] < minRowValue) {\n      minRowValue = rowValues[i];\n    }\n  }\n\n  // Знаходимо мінімальне значення стовпця, використовуючи цикл\n  let minColumnValue = columnValues[0];\n  for (let i = 1; i < columnValues.length; i++) {\n    if (columnValues[i] < minColumnValue) {\n      minColumnValue = columnValues[i];\n    }\n  }\n\n  // Повертаємо суму мінімальних значень рядка та стовпця\n  return minRowValue + minColumnValue;\n}\n\n/**\n * Знаходить максимальний штраф та ребро\n * @param {number[][]} penaltiesMatrix - Матриця штрафів\n * @return {object} - Об'єкт з максимальним штрафом та його координатами { value, row, column }\n */\n// Початковий масив для зберігання координат ребер\nexport let paths = [];\n\nexport function findMaxPenalty(penaltiesMatrix) {\n  let maxValue = -Infinity; //  максимальне значення штрафу (на початку ініціалізуємо як нуль)\n  let maxRow = null; // номера рядка максимального штрафу\n  let maxColumn = null; // номера стовпця максимального штрафу\n\n  // Проходимося по кожному елементу матриці штрафів\n  for (let i = 0; i < penaltiesMatrix.length; i += 1) {\n    for (let j = 0; j < penaltiesMatrix[i].length; j += 1) {\n      // Якщо поточний штраф більший за максимальний\n      if (penaltiesMatrix[i][j] !== null && penaltiesMatrix[i][j] > maxValue) {\n        maxValue = penaltiesMatrix[i][j]; // Оновлюємо максимальне значення штрафу\n        maxRow = i; // Зберігаємо номер рядка поточного максимального штрафу\n        maxColumn = j; // Зберігаємо номер стовпця поточного максимального штрафу\n      } else if (\n        penaltiesMatrix[i][j] !== null &&\n        penaltiesMatrix[i][j] === maxValue\n      ) {\n        // Якщо є декілька максимальних значень, вибираємо той, де менше i та j\n        if (i < maxRow || (i === maxRow && j < maxColumn)) {\n          // Зберігаємо номер рядка та стовпця поточного максимального штрафу\n          maxRow = i;\n          maxColumn = j;\n        }\n      }\n    }\n  }\n\n  // Додаємо координати рядка та стовпця максимального штрафу до масиву ребер\n  paths.push([maxRow + 1, maxColumn + 1]); // Додаємо координати рядка та стовпця (+1 для збігу з порядковим номером)\n\n  // координати задаються не індексом, а порядковим номером (+1)\n  return { value: maxValue, row: maxRow + 1, column: maxColumn + 1 };\n}\n","// Заміна значень рядка та стовпця на Infinity\nexport function replaceRowAndColumnWithInfinity(matrix, row, column) {\n  return matrix.map((r, i) =>\n    r.map((value, j) => (i === row - 1 || j === column - 1 ? Infinity : value))\n  );\n\n  // row - 1 -> оскільки беремо індекс, а не порядковий номер (maxPenalty.row = maxPenalty.index+1)\n}\n\n// Заборона негамільтонових циклів\nexport function preventCycles(matrix, edges) {\n  for (const [start, end] of edges) {\n    // Заборонити перехід між симетричними координатами\n    if (matrix[end - 1][start - 1] !== Infinity) {\n      matrix[end - 1][start - 1] = Infinity;\n      console.log(`Симетричний перехід (${end}, ${start}) заборонено`);\n    }\n\n    for (const [otherStart, otherEnd] of edges) {\n      if (\n        start !== otherStart &&\n        start !== otherEnd &&\n        end !== otherEnd &&\n        end !== otherStart\n      ) {\n        console.log(\n          'Знайдено цикл (координати не мають однакових значень)',\n          [start, end],\n          [otherStart, otherEnd]\n        );\n\n        const transitions = new Set([\n          [start, otherStart],\n          [start, otherEnd],\n          [end, otherStart],\n          [end, otherEnd],\n          [otherStart, start],\n          [otherStart, end],\n          [otherEnd, start],\n          [otherEnd, end],\n        ]);\n\n        for (const [vertex1, vertex2] of transitions) {\n          if (\n            !edges.some(edge => edge[0] === vertex1 && edge[1] === vertex2) &&\n            matrix[vertex1 - 1][vertex2 - 1] !== Infinity\n          ) {\n            matrix[vertex1 - 1][vertex2 - 1] = Infinity;\n            console.log(`Заборонено перехід (${vertex1}, ${vertex2})`);\n          }\n        }\n      }\n    }\n  }\n\n  return matrix;\n}\n\n// function doOperations(modifiedMatrix, minBorder) {\n//   console.log(subEveryRow(modifiedMatrix, minBorder));\n//   console.log(subEveryColumn(modifiedMatrix, minBorder));\n// }\n\n// doOperations(modifiedMatrix, newMinBorderCols);\n\n///////////////////////  NOTES\n// CASE-1. Not Bad ;))\n// function forbidNonHamiltonianCycles(matrix, edges) {\n//   for (let i = 0; i < edges.length; i += 1) {\n//     const start = edges[i][0];\n//     const end = edges[i][1];\n\n//     // Заборонити перехід між симетричними координатами\n//     if (matrix[end - 1][start - 1] !== Infinity) {\n//       matrix[end - 1][start - 1] = Infinity;\n//       console.log(\n//         `Симетричний перехід від вершини ${end} до вершини ${start} заборонено`\n//       );\n//     }\n\n//     for (let j = 0; j < edges.length; j += 1) {\n//       if (i !== j) {\n//         const otherStart = edges[j][0];\n//         const otherEnd = edges[j][1];\n\n//         if (\n//           start !== otherStart &&\n//           start !== otherEnd &&\n//           end !== otherEnd &&\n//           end !== otherStart\n//         ) {\n//           console.log(\n//             'Знайдено цикл (координати не мають однакових значень)',\n//             [start, end],\n//             [otherStart, otherEnd]\n//           );\n\n//           const transitions = [\n//             [start, otherStart],\n//             [start, otherEnd],\n//             [end, otherStart],\n//             [end, otherEnd],\n//             [otherStart, start],\n//             [otherStart, end],\n//             [otherEnd, start],\n//             [otherEnd, end],\n//           ];\n\n//           transitions.forEach(([vertex1, vertex2]) => {\n//             if (\n//               !edges.some(edge => edge[0] === vertex1 && edge[1] === vertex2)\n//             ) {\n//               matrix[vertex1 - 1][vertex2 - 1] = Infinity;\n//               console.log(\n//                 `Заборонено перехід від вершини ${vertex1} до вершини ${vertex2}`\n//               );\n//             }\n//           });\n//         }\n//       }\n//     }\n//   }\n\n//   return matrix;\n// }\n\n// CASE-2. REFERENCE\n// Заборона негамільтонових циклів\n// /**\n//  * Предотвращение негамильтоновых контуров (циклов)\n//  * Изменяет path\n//  * @param {number[][]} matrix - Вхідна матриця\n//  * @param {number[][]} path - Матриця шляхів\n//  * @return {number[][]} - Матриця зі зміненими значеннями\n//  */\n// export function preventCycle(matrix, path) {\n//   // console.log('Поиск циклов');\n//   let paths = path;\n//   let pathCopy = [...path];\n//   for (let row in paths) {\n//     let column = paths[row];\n//     if (matrix[column][row] !== undefined) {\n//       matrix[column][row] = Infinity;\n//     }\n//     for (let rowCopy in pathCopy) {\n//       let columnCopy = pathCopy[rowCopy];\n//       if (row === columnCopy) {\n//         paths[rowCopy] = column;\n//         delete paths[row];\n//         if (matrix[rowCopy][column] !== undefined) {\n//           matrix[rowCopy][column] = Infinity;\n//         }\n//         if (matrix[column][rowCopy] !== undefined) {\n//           matrix[column][rowCopy] = Infinity;\n//         }\n//         console.log(`Цикл найден. уничтожен [${rowCopy}][${column}]`);\n//         return preventCycle(matrix, paths);\n//       }\n//     }\n//   }\n//   console.log('Цикл не найден');\n//   return matrix;\n// }\n\n// CASE-3. PREVENT ONLY SYMMETRIC\n// function forbidNonHamiltonianCycles(matrix, edges) {\n//   // Перевіряємо кожне ребро з масиву ребер\n//   //   for (const [start, end] of edgesArray) {\n//   //     // Забороняємо перехід від start до end\n//   //     matrix[end - 1][start - 1] = Infinity;\n//   //     console.log(end - 1, start - 1);\n//   //   }\n\n//   for (let i = 0; i < edges.length; i += 1) {\n//     console.log(edges[i]);\n//     const start = edges[i][0];\n//     const end = edges[i][1];\n\n//     // Забороняємо перехід від start до end\n//     matrix[end - 1][start - 1] = Infinity;\n//   }\n\n//   //   return matrix;\n// }\n","// Pohorila Dariia\nimport * as taskGenerator from '../../generator/taskGenerator.js';\nimport * as matrixReduction from './matrixReduction.js';\nimport * as penalties from './penalties.js';\nimport * as etapThree from './etapThree.js';\n\n// let matrix = taskGenerator.generateMatrix(8, 15, 5);\n// console.table(matrix);\n\n// Матриця переналаштувань\nconsole.log('МАТРИЦЯ ПЕРЕНАЛАШТУВАНЬ');\nlet precedenceMatrix = [\n  [Infinity, 15, Infinity, 20, Infinity, 5, Infinity, 10],\n  [5, Infinity, 15, Infinity, 5, Infinity, 10, Infinity],\n  [Infinity, 20, Infinity, 15, Infinity, 5, Infinity, 5],\n  [10, Infinity, 20, Infinity, 5, Infinity, 10, Infinity],\n  [Infinity, 15, Infinity, 15, Infinity, 5, Infinity, 5],\n  [10, Infinity, 15, Infinity, 10, Infinity, 10, Infinity],\n  [Infinity, 20, Infinity, 20, Infinity, 10, Infinity, 5],\n  [5, Infinity, 15, Infinity, 5, Infinity, 5, Infinity],\n];\nconsole.table(precedenceMatrix);\n\n// Чи розмірність матриці 2х2\nfunction isSizeTwoByTwo(precedenceMatrix) {\n  let numOfValues = 0;\n\n  for (let i = 0; i < precedenceMatrix.length; i += 1) {\n    for (let j = 0; j < precedenceMatrix.length; j += 1) {\n      if (precedenceMatrix[i][j] !== Infinity) {\n        numOfValues += 1;\n      }\n    }\n  }\n\n  if (numOfValues === 4) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// console.log(isSizeTwoByTwo(precedenceMatrix));\n\n// while (isSizeTwoByTwo(precedenceMatrix)) {\n// }\n\nfor (let i = 0; i <= 1; i += 1) {\n  console.log(`ІТЕРАЦІЯ №${i + 1}`);\n  let minBorder = 0;\n  ///// ЕТАП-1. ЗВЕДЕННЯ МАТРИЦІ\n  console.log('ЕТАП-1. ЗВЕДЕННЯ МАТРИЦІ');\n  let minsByCols = matrixReduction.minFromColumns(precedenceMatrix);\n  console.log('Мінімальні по стовпцях:', minsByCols.join(' '));\n\n  // Віднімання мінімумів по стовпцях\n  precedenceMatrix = matrixReduction.subEveryColumn(precedenceMatrix);\n  console.log('Матриця після віднімання мінімумів по стовпцях:');\n  console.table(precedenceMatrix);\n\n  // Знайти мінімальні елементи по рядкам\n  let minsByRows = matrixReduction.minFromRows(precedenceMatrix);\n  console.log('Мінімальні по рядкам:', minsByRows.join(' '));\n\n  // Віднімання мінімумів по рядках\n  precedenceMatrix = matrixReduction.subEveryRow(precedenceMatrix);\n  console.log('Матриця після віднімання мінімумів по рядках:');\n  console.table(precedenceMatrix);\n  let sumOfMins = matrixReduction.sumOfMins(minsByCols, minsByRows);\n  minBorder += sumOfMins;\n  console.log('Нова мінімальна границя', minBorder);\n\n  ///// ЕТАП-2. ПОШУК ШТРАФІВ\n  // Матриця штрафів\n  console.log('ЕТАП-2. ОБЧИСЛЕННЯ ШТРАФІВ');\n  let penaltiesMatrix = penalties.calculatePenalties(precedenceMatrix);\n  console.log('Матриця штрафів для нулів:');\n  console.table(penaltiesMatrix);\n\n  // Максимальний штраф та ребро\n  let maxPenalty = penalties.findMaxPenalty(penaltiesMatrix);\n  console.log('Максимальний штраф:', maxPenalty.value);\n  console.log(`Ребро: (${maxPenalty.row}, ${maxPenalty.column})`);\n\n  // Масив знайдених ребер (додається автоматично в findMaxPenalty)\n  let path = penalties.paths;\n\n  ///// ЕТАП-3. ВИКЛЮЧЕННЯ РЕБРА\n  /**\n   * 1. В рядку і стовпчику знайденого ребра – Infinity\n   * 2. Заборона негамільтонових циклів\n   */\n  // Присвоюємо елементам рядка і стовпчика знайденого ребра значення Infinity\n  precedenceMatrix = etapThree.replaceRowAndColumnWithInfinity(\n    precedenceMatrix,\n    maxPenalty.row,\n    maxPenalty.column\n  );\n  console.log(\n    `Матриця після заміни ребра (${maxPenalty.row}, ${maxPenalty.column}) на Infinity: `\n  );\n  console.table(precedenceMatrix);\n\n  // Заборонити негамільтонові цикли\n  precedenceMatrix = etapThree.preventCycles(precedenceMatrix, path);\n  console.table(precedenceMatrix);\n\n  minsByCols = matrixReduction.minFromColumns(precedenceMatrix);\n  minsByRows = matrixReduction.minFromRows(precedenceMatrix);\n  sumOfMins = matrixReduction.sumOfMins(minsByCols, minsByRows);\n  console.log(sumOfMins);\n\n  // Розбиття на дві підмножини edge and !edge\n  // let edge = minBorder;\n  // let notEdge = minBorder;\n\n  // notEdge += maxPenalty.value;\n  // edge += sumOfMins;\n\n  // console.log(edge, notEdge);\n  // if (edge <= notEdge) {\n  //   console.log(\n  //     `Обираємо підмножину (${maxPenalty.row}, ${maxPenalty.column}) із γ = ${edge}`\n  //   );\n  // } else {\n  //   console.log(\n  //     `Обираємо підмножину (${maxPenalty.row}*, ${maxPenalty.column}*) із γ = ${notEdge}`\n  //   );\n  // }\n\n  // console.log(path);\n}\n\n// function createPath(paths) {\n//   if (paths.length > 1) {\n//     for (const [start, end] of paths) {\n//       for (const [otherStart, otherEnd] of paths) {\n//         if (\n//           start === otherStart ||\n//           start === otherEnd ||\n//           end === otherEnd ||\n//           end === otherStart\n//         ) {\n//           console.log(\n//             'координати мають однакові значень)',\n//             [start, end],\n//             [otherStart, otherEnd]\n//           );\n//         }\n//       }\n//     }\n//   } else {\n//   }\n// }\n\n// function findMinBorder(edge, notEdge) {}\n\n//============================================\n///// ЕТАП-1. ЗВЕДЕННЯ МАТРИЦІ\n// console.log('ЕТАП-1. ЗВЕДЕННЯ МАТРИЦІ');\n// Знаходження мінімальних елементів по стовпцях\n// let minsByCols = matrixReduction.minFromColumns(precedenceMatrix);\n// console.log('Мінімальні по стовпцях:', minsByCols.join(' '));\n\n// // Віднімання мінімумів по стовпцях\n// precedenceMatrix = matrixReduction.subEveryColumn(precedenceMatrix);\n// console.log('Матриця після віднімання мінімумів по стовпцях:');\n// console.table(precedenceMatrix);\n\n// // Знайти мінімальні елементи по рядкам\n// let minsByRows = matrixReduction.minFromRows(precedenceMatrix);\n// console.log('Мінімальні по рядкам:', minsByRows.join(' '));\n\n// // Віднімання мінімумів по рядках\n// precedenceMatrix = matrixReduction.subEveryRow(precedenceMatrix);\n// console.log('Матриця після віднімання мінімумів по рядках:');\n// console.table(precedenceMatrix);\n\n// let sumOfMins = matrixReduction.sumOfMins(minsByCols, minsByRows);\n// console.log('Нова мінімальна границя', sumOfMins);\n\n///// ЕТАП-2. ПОШУК ШТРАФІВ\n// Матриця штрафів\n// console.log('ЕТАП-2. ОБЧИСЛЕННЯ ШТРАФІВ');\n// let penaltiesMatrix = penalties.calculatePenalties(precedenceMatrix);\n// console.log('Матриця штрафів для нулів:');\n// console.table(penaltiesMatrix);\n\n// // Максимальний штраф та ребро\n// let maxPenalty = penalties.findMaxPenalty(penaltiesMatrix);\n// console.log('Максимальний штраф:', maxPenalty.value);\n// console.log(`Ребро: (${maxPenalty.row}, ${maxPenalty.column})`);\n\n// Масив знайдених ребер (додається автоматично в findMaxPenalty)\n// let edges = penalties.edgesArray;\n\n///// ЕТАП-3. ВИКЛЮЧЕННЯ РЕБРА\n/**\n * 1. В рядку і стовпчику знайденого ребра Infinity\n * 2. Заборона негамільтонових циклів\n */\n// Присвоюємо елементам рядка і стовпчика знайденого ребра значення Infinity\n// precedenceMatrix = etapThree.replaceRowAndColumnWithInfinity(\n//   precedenceMatrix,\n//   maxPenalty.row,\n//   maxPenalty.column\n// );\n// console.log(\n//   `Матриця після заміни ребра (${maxPenalty.row}, ${maxPenalty.column}) на Infinity: `\n// );\n// console.table(precedenceMatrix);\n\n// // Заборонити негамільтонові цикли\n// precedenceMatrix = etapThree.preventCycles(precedenceMatrix, edges);\n// console.table(precedenceMatrix);\n//============================================\n\n// // Знаходження мінімальних елементів по стовпцях\n// minsByCols = matrixReduction.minFromColumns(precedenceMatrix);\n// console.log('Мінімальні по стовпцях:', minsByCols.join(' '));\n\n// // Віднімання мінімумів по стовпцях\n// let { matrix: newMatrixCols1, newMinBorderCols1 } =\n//   matrixReduction.subEveryColumn(precedenceMatrix, newMinBorderRows);\n\n// precedenceMatrix = newMatrixCols1; // присвоїти початковій матриці нову\n\n// console.table(precedenceMatrix);\n\n// // Знайти мінімальні елементи по рядкам\n// minsByRows = matrixReduction.minFromRows(precedenceMatrix);\n// console.log('Мінімальні по рядкам:', minsByRows.join(' '));\n\n// // Віднімання мінімумів по рядках\n// let { matrix: newMatrixRows1, newMinBorderRows1 } = matrixReduction.subEveryRow(\n//   precedenceMatrix,\n//   newMinBorderCols\n// );\n\n// precedenceMatrix = newMatrixRows1; // присвоїти початковій матриці нову\n\n// console.log('Матриця після віднімання мінімумів по рядках:');\n// console.table(precedenceMatrix);\n\n// let sum = matrixReduction.sumOfMins(precedenceMatrix);\n// console.log(sum);\n\n// function unsetRowColumn(table, row, column) {\n//   console.log(`Удаление из матрицы ${row}:${column}`);\n//   row -= 1;\n//   column -= 1;\n//   table.splice(row, 1);\n//   table.forEach(row => row.splice(column, 1));\n//   console.log(`Результат удаления из матрицы ${row + 1}:${column + 1}`);\n//   return table;\n// }\n\n// function unsetRowColumn(table, row, column) {\n//   console.log(`Удаление из матрицы ${row}:${column}`);\n\n//   // Помітимо рядок та стовпець як видалені\n//   for (let i = 0; i < table.length; i++) {\n//     if (i === row - 1) {\n//       table[i] = Array(table[i].length).fill(null);\n//     } else {\n//       table[i][column - 1] = null;\n//     }\n//   }\n\n//   console.log(`Результат удаления из матрицы ${row}:${column}`);\n\n//   return table;\n// }\n\n// precedenceMatrix = unsetRowColumn(\n//   precedenceMatrix,\n//   maxPenalty.row,\n//   maxPenalty.column\n// );\n\n// console.table(precedenceMatrix);\n\n// Віднімання мінімумів по стовпцях\n// let { matrix: newMatrixCols, newMinBorderCols } =\n//   matrixReduction.subEveryColumn(precedenceMatrix, 0);\n\n// precedenceMatrix = newMatrixCols; // присвоїти початковій матриці нову\n\n// console.log('Матриця після віднімання мінімумів по стовпцях:');\n// console.table(newMatrixCols);\n// console.log('Нова мінімальна границя:', newMinBorderCols);\n\n// Віднімання мінімумів по рядках\n// let { matrix: newMatrixRows, newMinBorderRows } = matrixReduction.subEveryRow(\n//   precedenceMatrix,\n//   newMinBorderCols\n// );\n\n// precedenceMatrix = newMatrixRows; // присвоїти початковій матриці нову\n\n// console.log('Матриця після віднімання мінімумів по рядках:');\n// console.table(precedenceMatrix);\n// console.log('Нова мінімальна границя:', newMinBorderRows);\n\n// let sumOfRedConstants = matrixReduction.sumOfReducedElements(\n//   minsByCols,\n//   minsByRows\n// );\n\n// console.log(sumOfRedConstants);\n"],"names":["minFromColumns","matrix","mins","column","columnValues","row","subEveryColumn","value","j","minFromRows","subEveryRow","i","sumOfMins","sumValidMins","min","acc","curr","sumRows","sumCols","calculatePenalties","penalties","calculatePenaltyForRowAndColumn","rowValues","index","minRowValue","minColumnValue","paths","findMaxPenalty","penaltiesMatrix","maxValue","maxRow","maxColumn","replaceRowAndColumnWithInfinity","r","preventCycles","edges","start","end","otherStart","otherEnd","transitions","vertex1","vertex2","edge","precedenceMatrix","minBorder","minsByCols","matrixReduction.minFromColumns","matrixReduction.subEveryColumn","minsByRows","matrixReduction.minFromRows","matrixReduction.subEveryRow","matrixReduction.sumOfMins","penalties.calculatePenalties","maxPenalty","penalties.findMaxPenalty","path","penalties.paths","etapThree.replaceRowAndColumnWithInfinity","etapThree.preventCycles"],"mappings":"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"}