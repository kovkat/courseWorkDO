{"version":3,"file":"commonHelpers.js","sources":["../src/js/algorithms/branchBound/reduction.js","../src/js/algorithms/branchBound/preventCycle.js","../src/js/algorithms/branchBound/branchesAndBounds.js"],"sourcesContent":["// Функція для редукції матриці (мінімізація по рядках і стовпцях)\nexport function reduceMatrix(matrix, index) {\n  let sumMinRows = 0; // Сума мінімальних значень по рядках\n  let sumMinColumns = 0; // Сума мінімальних значень по стовпцях\n\n  //MINROW\n  matrix.forEach((array, index) => {\n    let min = Math.min.apply(null, array); // Знаходження мінімального значення в рядку\n    if (isNaN(min) || !isFinite(min)) {\n      min = 0; // Якщо значення не є числом або не є кінцевим, встановити 0\n    }\n    sumMinRows += min; // Додати мінімальне значення до суми\n    let minimizedRow = array.map(number => {\n      return (number -= min); // Відняти мінімальне значення з кожного елемента рядка\n    });\n    matrix[index] = minimizedRow; // Оновити рядок в матриці\n  });\n\n  //TRANSPOSED\n  matrix = matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));\n\n  //MINCOL\n  matrix.forEach((array, index) => {\n    let min = Math.min.apply(null, array);\n    if (isNaN(min) || !isFinite(min)) {\n      min = 0;\n    }\n    sumMinColumns += min;\n    let minimizedColumn = array.map(number => {\n      return (number -= min);\n    });\n    matrix[index] = minimizedColumn;\n  });\n\n  //DISTRAMPOSE\n  matrix = matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));\n\n  let total = sumMinRows + sumMinColumns; // Загальна вартість мінімізації\n\n  let node = {\n    index: index,\n    matrix: matrix,\n    cost: total,\n  };\n\n  return node;\n}\n","export function setRowColumnInfinity(matrix, from, to) {\n  // Функція для встановлення нескінченності у вказаних рядках та стовпцях\n  const thisMatrix = matrix.map(row => row.slice());\n\n  for (let i = 0; i < matrix.length; i += 1) {\n    thisMatrix[from][i] = Infinity; // Встановлення нескінченності в рядку\n    thisMatrix[i][to] = Infinity; // Встановлення нескінченності в стовпці\n    thisMatrix[to][from] = Infinity; // Встановлення нескінченності у зворотному напрямку\n    thisMatrix[to][0] = Infinity; // Встановлення нескінченності в першому елементі стовпця\n  }\n\n  return thisMatrix;\n}\n","// Pohorila Dariia\nimport * as Generator from '../../generator/taskGenerator.js';\nimport * as matrixReduction from './reduction.js';\nimport * as preventCycle from './preventCycle.js';\n\n// МАТРИЦЯ ПЕРЕНАЛАШТУВАНЬ\n// let matrix1 = Generator.generateMatrix(8, 15, 5);\n\nlet matrix = [\n  [Infinity, 15, Infinity, 20, Infinity, 5, Infinity, 10],\n  [5, Infinity, 15, Infinity, 5, Infinity, 10, Infinity],\n  [Infinity, 20, Infinity, 15, Infinity, 5, Infinity, 5],\n  [10, Infinity, 20, Infinity, 5, Infinity, 10, Infinity],\n  [Infinity, 15, Infinity, 15, Infinity, 5, Infinity, 5],\n  [10, Infinity, 15, Infinity, 10, Infinity, 10, Infinity],\n  [Infinity, 20, Infinity, 20, Infinity, 10, Infinity, 5],\n  [5, Infinity, 15, Infinity, 5, Infinity, 5, Infinity],\n];\n\nconsole.log('\\nМАТРИЦЯ ПЕРЕНАЛАШТУВАНЬ');\nconsole.table(matrix);\n\n// Метод границь і меж\nfunction branchAndBound(matrixData) {\n  // Встановлення нескінченності на діагоналі матриці\n  for (let i = 0; i < matrixData.length; i += 1) {\n    for (let j = 0; j < matrixData.length; j += 1) {\n      if (i == j) {\n        matrixData[i][j] = Infinity;\n      }\n    }\n  }\n\n  const minCostArray = []; // Масив для збереження мінімальної вартості\n  const objRoot = matrixReduction.reduceMatrix(matrixData, 0); // Початкова редукція матриці\n  minCostArray.push({\n    index: objRoot.index,\n    cost: objRoot.cost,\n  });\n\n  let row = objRoot.index; // Початковий рядок\n  let prevMatrix = objRoot.matrix.map(row => row.slice());\n  let prevCost = objRoot.cost; // Початкова вартість\n\n  // Прохід по всіх рядках матриці\n  for (let index = 0; index < matrixData.length - 1; index++) {\n    let objArrayTemp = []; // Тимчасовий масив для збереження вузлів\n    for (let column = 1; column < matrixData.length; column++) {\n      const infRowColumn = preventCycle.setRowColumnInfinity(\n        prevMatrix,\n        row,\n        column\n      ); // Встановлення нескінченності у рядках та стовпцях\n      const objNode = matrixReduction.reduceMatrix(infRowColumn, column); // Редукція нової матриці\n\n      objNode.cost = objNode.cost + prevCost + prevMatrix[row][column]; // Оновлення вартості вузла\n      objArrayTemp.push(objNode); // Додавання вузла до тимчасового масиву\n      //   console.log(\"Node: %d - Cost: %d\", objNode.index, objNode.cost);\n    }\n\n    // Знаходження вузла з мінімальною вартістю\n    let objMinCost = objArrayTemp.reduce(function (prev, curr) {\n      return prev.cost < curr.cost ? prev : curr;\n    });\n    console.log(' Node: %d - Cost: %d ', objMinCost.index + 1, objMinCost.cost);\n\n    minCostArray.push({\n      index: objMinCost.index,\n      cost: objMinCost.cost,\n    });\n\n    row = objMinCost.index;\n    prevMatrix = objMinCost.matrix.map(row => row.slice());\n    prevCost = objMinCost.cost;\n  }\n\n  // Витяг останнього значення cost з масиву minCostArray\n  const lastCost = minCostArray[minCostArray.length - 1].cost;\n  // console.log('Сума переналаштувань:', lastCost);\n\n  return { minCostArray, lastCost };\n}\n\nconsole.log('\\nВУЗЛИ');\nconst { minCostArray, lastCost } = branchAndBound(matrix);\n\nconsole.log('\\nminCostArray:\\n');\nminCostArray.forEach((item, index) => {\n  console.log(`Index: ${index}, Cost: ${item.cost}`);\n});\n\nconsole.log('\\nСума переналаштувань:', lastCost);\n\n// ТРИВАЛОСТІ УРОКІВ\nfunction sumOfDurations(durations) {\n  return durations.reduce((acc, duration) => acc + duration, 0);\n}\n\nconst trainingDuration = [40, 120, 90, 90, 60, 50, 60, 40];\nconst totalDuration = sumOfDurations(trainingDuration);\nconsole.log(`Тривалість уроків: `, totalDuration); // Total duration: 550 minutes\n\nfunction calcTrainerWorkTime(totalDuration, lastCost) {\n  return totalDuration + lastCost;\n}\n\nconst totalWorkTime = calcTrainerWorkTime(totalDuration, lastCost);\nconsole.log('Загальний час роботи тренера', totalWorkTime, '\\n');\n"],"names":["reduceMatrix","matrix","index","sumMinRows","sumMinColumns","array","min","minimizedRow","number","_","colIndex","row","minimizedColumn","total","setRowColumnInfinity","from","to","thisMatrix","i","branchAndBound","matrixData","j","minCostArray","objRoot","matrixReduction.reduceMatrix","prevMatrix","prevCost","objArrayTemp","column","infRowColumn","preventCycle.setRowColumnInfinity","objNode","objMinCost","prev","curr","lastCost","item","sumOfDurations","durations","acc","duration","trainingDuration","totalDuration","calcTrainerWorkTime","totalWorkTime"],"mappings":"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"}