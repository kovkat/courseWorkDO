{"version":3,"file":"commonHelpers.js","sources":["../src/js/algorithms/branchesAndBounds/matrixReduction.js","../src/js/algorithms/branchesAndBounds/penalties.js","../src/js/algorithms/branchesAndBounds/etapThree.js","../src/js/algorithms/branchesAndBounds/branchesAndBounds.js"],"sourcesContent":["// Знаходження мінімальних елементів по рядкам\nexport function minFromRows(matrix) {\n  return matrix.map(row => Math.min(...row));\n}\n\n// Віднімання мінімумів по рядках\nexport function subEveryRow(matrix, newMinBorderRows) {\n  const mins = minFromRows(matrix);\n  newMinBorderRows += mins.reduce((acc, curr) => acc + curr, 0);\n\n  const newMatrix = matrix.map((row, i) =>\n    row.map((value, j) => value - mins[i])\n  );\n\n  return { matrix: newMatrix, newMinBorderRows };\n}\n\n// Знаходження мінімальних елементів по стовпцях\nexport function minFromColumns(matrix) {\n  const mins = [];\n  const columns = Object.keys(matrix[0]);\n\n  columns.forEach(column => {\n    const columnValues = matrix.map(row => row[column]);\n    mins[column] = Math.min(...columnValues);\n  });\n\n  return mins;\n}\n\n// Віднімання мінімумів по стовпцях\nexport function subEveryColumn(matrix, newMinBorderCols) {\n  const mins = minFromColumns(matrix);\n  newMinBorderCols += Object.values(mins).reduce((acc, curr) => acc + curr, 0);\n\n  const newMatrix = matrix.map((row, i) =>\n    row.map((value, j) => value - mins[j])\n  );\n\n  return { matrix: newMatrix, newMinBorderCols };\n}\n\n// Сума констант зведення\nexport function sumOfReducedElements(minsByCols, minsByRows) {\n  let totalSum = 0;\n  for (let i = 0; i < minsByCols.length; i += 1) {\n    totalSum += minsByCols[i];\n  }\n\n  for (let i = 0; i < minsByRows.length; i += 1) {\n    totalSum += minsByRows[i];\n  }\n\n  return totalSum;\n}\n","/**\n * Обчислює штраф для кожного нуля в матриці\n * @param {number[][]} matrix - Вхідна матриця\n * @return {number[][]} - Матриця штрафів\n */\nexport function calculatePenalties(matrix) {\n  const penalties = []; // масив для матриці штрафів\n\n  // Проходимося по кожному рядку матриці\n  for (let i = 0; i < matrix.length; i += 1) {\n    penalties[i] = []; // масив для рядка матриці штрафів\n\n    // Проходимося по кожному елементу у рядку\n    for (let j = 0; j < matrix[i].length; j += 1) {\n      // Якщо знаходимо нуль\n      if (matrix[i][j] === 0) {\n        // console.log('нуль');\n        penalties[i][j] = calculatePenaltyForRowAndColumn(matrix, i, j);\n      } else {\n        penalties[i][j] = null; // Штраф не обчислюється для не-нульових елементів\n      }\n    }\n  }\n\n  return penalties;\n}\n\n/**\n * Обчислює штраф для нуля у вказаному рядку та стовпці\n * @param {number[][]} matrix - Вхідна матриця\n * @param {number} row - Номер рядка\n * @param {number} column - Номер стовпця\n * @return {number} - Штраф для нуля\n */\nexport function calculatePenaltyForRowAndColumn(matrix, row, column) {\n  // Фільтруємо значення рядка, виключаючи поточний нуль та Infinity\n  const rowValues = matrix[row].filter(\n    (value, index) => index !== column && value !== Infinity\n  );\n\n  // Фільтруємо значення стовпця, виключаючи Infinity\n  const columnValues = matrix\n    .map(row => row[column])\n    .filter(value => value !== Infinity);\n\n  // Знаходимо мінімальне значення рядка, якщо є такі значення\n  const minRowValue = rowValues.length > 0 ? Math.min(...rowValues) : 0;\n\n  // Знаходимо мінімальне значення стовпця, якщо є такі значення\n  const minColumnValue =\n    columnValues.length > 0 ? Math.min(...columnValues) : 0;\n\n  // Повертаємо суму мінімальних значень рядка та стовпця\n  return minRowValue + minColumnValue;\n}\n\n/**\n * Знаходить максимальний штраф та ребро\n * @param {number[][]} penaltiesMatrix - Матриця штрафів\n * @return {object} - Об'єкт з максимальним штрафом та його координатами { value, row, column }\n */\n// Початковий масив для зберігання координат ребер\nexport let edgesArray = [];\n\nexport function findMaxPenalty(penaltiesMatrix) {\n  let maxValue = -Infinity; //  максимальне значення штрафу (на початку ініціалізуємо як нуль)\n  let maxRow = null; // номера рядка максимального штрафу\n  let maxColumn = null; // номера стовпця максимального штрафу\n\n  // Проходимося по кожному елементу матриці штрафів\n  for (let i = 0; i < penaltiesMatrix.length; i += 1) {\n    for (let j = 0; j < penaltiesMatrix[i].length; j += 1) {\n      // Якщо поточний штраф більший за максимальний\n      if (penaltiesMatrix[i][j] !== null && penaltiesMatrix[i][j] > maxValue) {\n        maxValue = penaltiesMatrix[i][j]; // Оновлюємо максимальне значення штрафу\n        maxRow = i; // Зберігаємо номер рядка поточного максимального штрафу\n        maxColumn = j; // Зберігаємо номер стовпця поточного максимального штрафу\n      } else if (\n        penaltiesMatrix[i][j] !== null &&\n        penaltiesMatrix[i][j] === maxValue\n      ) {\n        // Якщо є декілька максимальних значень, вибираємо той, де менше i та j\n        if (i < maxRow || (i === maxRow && j < maxColumn)) {\n          // Зберігаємо номер рядка та стовпця поточного максимального штрафу\n          maxRow = i;\n          maxColumn = j;\n        }\n      }\n    }\n  }\n\n  // Додаємо координати рядка та стовпця максимального штрафу до масиву ребер\n  edgesArray.push([maxRow + 1, maxColumn + 1]); // Додаємо координати рядка та стовпця (+1 для збігу з порядковим номером)\n\n  // координати задаються не індексом, а порядковим номером (+1)\n  return { value: maxValue, row: maxRow + 1, column: maxColumn + 1 };\n}\n","// Заміна значень рядка та стовпця на Infinity\nexport function replaceRowAndColumnWithInfinity(matrix, row, column) {\n  return matrix.map((r, i) =>\n    r.map((value, j) => (i === row - 1 || j === column - 1 ? Infinity : value))\n  );\n\n  // row - 1 -> оскільки беремо індекс, а не порядковий номер (maxPenalty.row = maxPenalty.index+1)\n}\n\n// Заборона негамільтонових циклів\nexport function preventCycles(matrix, edges) {\n  for (const [start, end] of edges) {\n    // Заборонити перехід між симетричними координатами\n    if (matrix[end - 1][start - 1] !== Infinity) {\n      matrix[end - 1][start - 1] = Infinity;\n      console.log(`Симетричний перехід (${end}, ${start}) заборонено`);\n    }\n\n    for (const [otherStart, otherEnd] of edges) {\n      if (\n        start !== otherStart &&\n        start !== otherEnd &&\n        end !== otherEnd &&\n        end !== otherStart\n      ) {\n        console.log(\n          'Знайдено цикл (координати не мають однакових значень)',\n          [start, end],\n          [otherStart, otherEnd]\n        );\n\n        const transitions = new Set([\n          [start, otherStart],\n          [start, otherEnd],\n          [end, otherStart],\n          [end, otherEnd],\n          [otherStart, start],\n          [otherStart, end],\n          [otherEnd, start],\n          [otherEnd, end],\n        ]);\n\n        for (const [vertex1, vertex2] of transitions) {\n          if (\n            !edges.some(edge => edge[0] === vertex1 && edge[1] === vertex2) &&\n            matrix[vertex1 - 1][vertex2 - 1] !== Infinity\n          ) {\n            matrix[vertex1 - 1][vertex2 - 1] = Infinity;\n            console.log(`Заборонено перехід (${vertex1}, ${vertex2})`);\n          }\n        }\n      }\n    }\n  }\n\n  return matrix;\n}\n\n// function doOperations(modifiedMatrix, minBorder) {\n//   console.log(subEveryRow(modifiedMatrix, minBorder));\n//   console.log(subEveryColumn(modifiedMatrix, minBorder));\n// }\n\n// doOperations(modifiedMatrix, newMinBorderCols);\n\n///////////////////////  NOTES\n// CASE-1. Not Bad ;))\n// function forbidNonHamiltonianCycles(matrix, edges) {\n//   for (let i = 0; i < edges.length; i += 1) {\n//     const start = edges[i][0];\n//     const end = edges[i][1];\n\n//     // Заборонити перехід між симетричними координатами\n//     if (matrix[end - 1][start - 1] !== Infinity) {\n//       matrix[end - 1][start - 1] = Infinity;\n//       console.log(\n//         `Симетричний перехід від вершини ${end} до вершини ${start} заборонено`\n//       );\n//     }\n\n//     for (let j = 0; j < edges.length; j += 1) {\n//       if (i !== j) {\n//         const otherStart = edges[j][0];\n//         const otherEnd = edges[j][1];\n\n//         if (\n//           start !== otherStart &&\n//           start !== otherEnd &&\n//           end !== otherEnd &&\n//           end !== otherStart\n//         ) {\n//           console.log(\n//             'Знайдено цикл (координати не мають однакових значень)',\n//             [start, end],\n//             [otherStart, otherEnd]\n//           );\n\n//           const transitions = [\n//             [start, otherStart],\n//             [start, otherEnd],\n//             [end, otherStart],\n//             [end, otherEnd],\n//             [otherStart, start],\n//             [otherStart, end],\n//             [otherEnd, start],\n//             [otherEnd, end],\n//           ];\n\n//           transitions.forEach(([vertex1, vertex2]) => {\n//             if (\n//               !edges.some(edge => edge[0] === vertex1 && edge[1] === vertex2)\n//             ) {\n//               matrix[vertex1 - 1][vertex2 - 1] = Infinity;\n//               console.log(\n//                 `Заборонено перехід від вершини ${vertex1} до вершини ${vertex2}`\n//               );\n//             }\n//           });\n//         }\n//       }\n//     }\n//   }\n\n//   return matrix;\n// }\n\n// CASE-2. REFERENCE\n// Заборона негамільтонових циклів\n// /**\n//  * Предотвращение негамильтоновых контуров (циклов)\n//  * Изменяет path\n//  * @param {number[][]} matrix - Вхідна матриця\n//  * @param {number[][]} path - Матриця шляхів\n//  * @return {number[][]} - Матриця зі зміненими значеннями\n//  */\n// export function preventCycle(matrix, path) {\n//   // console.log('Поиск циклов');\n//   let paths = path;\n//   let pathCopy = [...path];\n//   for (let row in paths) {\n//     let column = paths[row];\n//     if (matrix[column][row] !== undefined) {\n//       matrix[column][row] = Infinity;\n//     }\n//     for (let rowCopy in pathCopy) {\n//       let columnCopy = pathCopy[rowCopy];\n//       if (row === columnCopy) {\n//         paths[rowCopy] = column;\n//         delete paths[row];\n//         if (matrix[rowCopy][column] !== undefined) {\n//           matrix[rowCopy][column] = Infinity;\n//         }\n//         if (matrix[column][rowCopy] !== undefined) {\n//           matrix[column][rowCopy] = Infinity;\n//         }\n//         console.log(`Цикл найден. уничтожен [${rowCopy}][${column}]`);\n//         return preventCycle(matrix, paths);\n//       }\n//     }\n//   }\n//   console.log('Цикл не найден');\n//   return matrix;\n// }\n\n// CASE-3. PREVENT ONLY SYMMETRIC\n// function forbidNonHamiltonianCycles(matrix, edges) {\n//   // Перевіряємо кожне ребро з масиву ребер\n//   //   for (const [start, end] of edgesArray) {\n//   //     // Забороняємо перехід від start до end\n//   //     matrix[end - 1][start - 1] = Infinity;\n//   //     console.log(end - 1, start - 1);\n//   //   }\n\n//   for (let i = 0; i < edges.length; i += 1) {\n//     console.log(edges[i]);\n//     const start = edges[i][0];\n//     const end = edges[i][1];\n\n//     // Забороняємо перехід від start до end\n//     matrix[end - 1][start - 1] = Infinity;\n//   }\n\n//   //   return matrix;\n// }\n","// Pohorila Dariia\nimport * as taskGenerator from '../../generator/taskGenerator.js';\nimport * as matrixReduction from './matrixReduction.js';\nimport * as penalties from './penalties.js';\nimport * as etapThree from './etapThree.js';\n\n// let matrix = taskGenerator.generateMatrix(8, 15, 5);\n// console.table(matrix);\n\n// Матриця переналаштувань\nconsole.log('МАТРИЦЯ ПЕРЕНАЛАШТУВАНЬ');\nlet precedenceMatrix = [\n  [Infinity, 15, Infinity, 20, Infinity, 5, Infinity, 10],\n  [5, Infinity, 15, Infinity, 5, Infinity, 10, Infinity],\n  [Infinity, 20, Infinity, 15, Infinity, 5, Infinity, 5],\n  [10, Infinity, 20, Infinity, 5, Infinity, 10, Infinity],\n  [Infinity, 15, Infinity, 15, Infinity, 5, Infinity, 5],\n  [10, Infinity, 15, Infinity, 10, Infinity, 10, Infinity],\n  [Infinity, 20, Infinity, 20, Infinity, 10, Infinity, 5],\n  [5, Infinity, 15, Infinity, 5, Infinity, 5, Infinity],\n];\nconsole.table(precedenceMatrix);\n\n///// ЕТАП-1. ЗВЕДЕННЯ МАТРИЦІ\nconsole.log('ЕТАП-1. ЗВЕДЕННЯ МАТРИЦІ');\n// Знаходження мінімальних елементів по стовпцях\nlet minsByCols = matrixReduction.minFromColumns(precedenceMatrix);\nconsole.log('Мінімальні по стовпцях:', minsByCols.join(' '));\n\n// Віднімання мінімумів по стовпцях\nlet { matrix: newMatrixCols, newMinBorderCols } =\n  matrixReduction.subEveryColumn(precedenceMatrix, 0);\n\nprecedenceMatrix = newMatrixCols; // присвоїти початковій матриці нову\n\nconsole.log('Матриця після віднімання мінімумів по стовпцях:');\nconsole.table(newMatrixCols);\nconsole.log('Нова мінімальна границя:', newMinBorderCols);\n\n// Знайти мінімальні елементи по рядкам\nlet minsByRows = matrixReduction.minFromRows(precedenceMatrix);\nconsole.log('Мінімальні по рядкам:', minsByRows.join(' '));\n\n// Віднімання мінімумів по рядках\nlet { matrix: newMatrixRows, newMinBorderRows } = matrixReduction.subEveryRow(\n  precedenceMatrix,\n  newMinBorderCols\n);\n\nprecedenceMatrix = newMatrixRows; // присвоїти початковій матриці нову\n\nconsole.log('Матриця після віднімання мінімумів по рядках:');\nconsole.table(precedenceMatrix);\nconsole.log('Нова мінімальна границя:', newMinBorderRows);\n\nlet sumOfRedConstants = matrixReduction.sumOfReducedElements(\n  minsByCols,\n  minsByRows\n);\n\nconsole.log(sumOfRedConstants);\n\n///// ЕТАП-2. ПОШУК ШТРАФІВ\n// Матриця штрафів\nconsole.log('ЕТАП-2. ОБЧИСЛЕННЯ ШТРАФІВ');\nlet penaltiesMatrix = penalties.calculatePenalties(precedenceMatrix);\nconsole.log('Матриця штрафів для нулів:');\nconsole.table(penaltiesMatrix);\n\n// Максимальний штраф та ребро\nlet maxPenalty = penalties.findMaxPenalty(penaltiesMatrix);\nconsole.log('Максимальний штраф:', maxPenalty.value);\nconsole.log(`Ребро: (${maxPenalty.row}, ${maxPenalty.column})`);\n\n// Масив знайдених ребер (додається автоматично в findMaxPenalty)\nlet edges = penalties.edgesArray;\n\n///// ЕТАП-3. ВИКЛЮЧЕННЯ РЕБРА\n/**\n * 1. В рядку і стовпчику знайденого ребра Infinity\n * 2. Заборона негамільтонових циклів\n */\n// Присвоюємо елементам рядка і стовпчика знайденого ребра значення Infinity\nprecedenceMatrix = etapThree.replaceRowAndColumnWithInfinity(\n  precedenceMatrix,\n  maxPenalty.row,\n  maxPenalty.column\n);\nconsole.log(\n  `Матриця після заміни ребра (${maxPenalty.row}, ${maxPenalty.column}) на Infinity: `\n);\nconsole.table(precedenceMatrix);\n\n// Заборонити негамільтонові цикли\nprecedenceMatrix = etapThree.preventCycles(precedenceMatrix, edges);\nconsole.table(precedenceMatrix);\n\n// function unsetRowColumn(table, row, column) {\n//   console.log(`Удаление из матрицы ${row}:${column}`);\n//   row -= 1;\n//   column -= 1;\n//   table.splice(row, 1);\n//   table.forEach(row => row.splice(column, 1));\n//   console.log(`Результат удаления из матрицы ${row + 1}:${column + 1}`);\n//   return table;\n// }\n\nfunction unsetRowColumn(table, row, column) {\n  console.log(`Удаление из матрицы ${row}:${column}`);\n\n  // Помітимо рядок та стовпець як видалені\n  for (let i = 0; i < table.length; i++) {\n    if (i === row - 1) {\n      table[i] = Array(table[i].length).fill(null);\n    } else {\n      table[i][column - 1] = null;\n    }\n  }\n\n  console.log(`Результат удаления из матрицы ${row}:${column}`);\n\n  return table;\n}\n\nprecedenceMatrix = unsetRowColumn(\n  precedenceMatrix,\n  maxPenalty.row,\n  maxPenalty.column\n);\n\nconsole.table(precedenceMatrix);\n\n// Знаходження мінімальних елементів по стовпцях\nminsByCols = matrixReduction.minFromColumns(precedenceMatrix);\nconsole.log('Мінімальні по стовпцях:', minsByCols.join(' '));\n\n// Віднімання мінімумів по стовпцях\nlet { matrix: newMatrixCols1, newMinBorderCols1 } =\n  matrixReduction.subEveryColumn(precedenceMatrix, newMinBorderRows);\n\nprecedenceMatrix = newMatrixCols; // присвоїти початковій матриці нову\n\n// console.log('Матриця після віднімання мінімумів по стовпцях:');\n// console.table(newMatrixCols);\n// console.log('Нова мінімальна границя:', newMinBorderCols);\n\n// Знайти мінімальні елементи по рядкам\n// let minsByRows = matrixReduction.minFromRows(precedenceMatrix);\n// console.log('Мінімальні по рядкам:', minsByRows.join(' '));\n\n// // Віднімання мінімумів по рядках\n// let { matrix: newMatrixRows, newMinBorderRows } = matrixReduction.subEveryRow(\n//   precedenceMatrix,\n//   newMinBorderCols\n// );\n\n// precedenceMatrix = newMatrixRows; // присвоїти початковій матриці нову\n\n// console.log('Матриця після віднімання мінімумів по рядках:');\n// console.table(precedenceMatrix);\n// console.log('Нова мінімальна границя:', newMinBorderRows);\n\n// let sumOfRedConstants = matrixReduction.sumOfReducedElements(\n//   minsByCols,\n//   minsByRows\n// );\n\n// console.log(sumOfRedConstants);\n\n// sumOfRedConstants = matrixReduction.sumOfReducedElements(\n//   minsByCols,\n//   minsByRows\n// );\n\n// console.log(sumOfRedConstants);\n"],"names":["minFromRows","matrix","row","subEveryRow","newMinBorderRows","mins","acc","curr","value","j","minFromColumns","column","columnValues","subEveryColumn","newMinBorderCols","sumOfReducedElements","minsByCols","minsByRows","totalSum","i","calculatePenalties","penalties","calculatePenaltyForRowAndColumn","rowValues","index","minRowValue","minColumnValue","edgesArray","findMaxPenalty","penaltiesMatrix","maxValue","maxRow","maxColumn","replaceRowAndColumnWithInfinity","r","preventCycles","edges","start","end","otherStart","otherEnd","transitions","vertex1","vertex2","edge","precedenceMatrix","matrixReduction.minFromColumns","newMatrixCols","matrixReduction.subEveryColumn","matrixReduction.minFromRows","newMatrixRows","matrixReduction.subEveryRow","sumOfRedConstants","matrixReduction.sumOfReducedElements","penalties.calculatePenalties","maxPenalty","penalties.findMaxPenalty","penalties.edgesArray","etapThree.replaceRowAndColumnWithInfinity","etapThree.preventCycles","unsetRowColumn","table"],"mappings":"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"}