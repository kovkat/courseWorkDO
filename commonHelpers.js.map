{"version":3,"file":"commonHelpers.js","sources":["../src/js/algorithms/branchAndBound.js"],"sourcesContent":["// Pohorila Dariia\nimport { generateMatrix } from '/js/generator/taskGenerator';\n\n// let matrix = generateMatrix(8, 15, 5);\n// console.table(matrix);\n\n/**\n * АЛГОРИТМ\n * 1. мінімальні по рядках\n * 2. мін по стовпцях\n * 3. зведення матриці\n *\n * 4. штрафи\n * 5. виключить даний стовпець і рядок з матриці\n * 6. заборонить гамільтоновий цикл\n */\n\nlet precedenceMatrix = [\n  [Infinity, 15, Infinity, 20, Infinity, 5, Infinity, 10],\n  [5, Infinity, 15, Infinity, 5, Infinity, 10, Infinity],\n  [Infinity, 20, Infinity, 15, Infinity, 5, Infinity, 5],\n  [10, Infinity, 20, Infinity, 5, Infinity, 10, Infinity],\n  [Infinity, 15, Infinity, 15, Infinity, 5, Infinity, 5],\n  [10, Infinity, 15, Infinity, 10, Infinity, 10, Infinity],\n  [Infinity, 20, Infinity, 20, Infinity, 10, Infinity, 5],\n  [5, Infinity, 15, Infinity, 5, Infinity, 5, Infinity],\n];\n\nconsole.log(precedenceMatrix);\n\n// Знаходження мінімальних елементів по рядкам\nfunction minFromRows(matrix) {\n  return matrix.map(row => Math.min(...row));\n}\n\nlet minsByRows = minFromRows(precedenceMatrix);\nconsole.log('Мінімальні по рядкам:', minsByRows.join(' '));\n\n// Віднімання мінімумів по рядках\nfunction subEveryRow(matrix, minBorder) {\n  const mins = minFromRows(matrix);\n  minBorder += mins.reduce((acc, curr) => acc + curr, 0);\n\n  const newMatrix = matrix.map((row, i) =>\n    row.map((value, j) => value - mins[i])\n  );\n\n  return { matrix: newMatrix, minBorder };\n}\n\nlet { matrix: newMatrixRows, minBorder: newMinBorderRows } = subEveryRow(\n  precedenceMatrix,\n  0\n);\nconsole.log('Матриця після віднімання мінімумів по рядках:', newMatrixRows);\nconsole.log('Нова мінімальна границя:', newMinBorderRows);\n\n// Знаходження мінімальних елементів по стовпцях\nfunction minFromColumns(matrix) {\n  const mins = [];\n  const columns = Object.keys(matrix[0]);\n\n  columns.forEach(column => {\n    const columnValues = matrix.map(row => row[column]);\n    mins[column] = Math.min(...columnValues);\n  });\n\n  return mins;\n}\n\nlet minsByCols = minFromColumns(precedenceMatrix);\nconsole.log('Мінімальні по стовпцях:', minsByCols.join(' '));\n\n// Віднімання мінімумів по стовпцях\nfunction subEveryColumn(matrix, minBorder) {\n  const mins = minFromColumns(matrix);\n  minBorder += Object.values(mins).reduce((acc, curr) => acc + curr, 0);\n\n  const newMatrix = matrix.map((row, i) =>\n    row.map((value, j) => value - mins[j])\n  );\n\n  return { matrix: newMatrix, minBorder };\n}\n\nlet { matrix: newMatrixCols, minBorder: newMinBorderCols } = subEveryColumn(\n  precedenceMatrix,\n  0\n);\nconsole.log('Матриця після віднімання мінімумів по стовпцях:', newMatrixCols);\nconsole.log('Нова мінімальна границя:', newMinBorderCols);\n\n/////========= ЕТАП-2. ОБЧИСЛЕННЯ ШТРАФІВ ===========////\n/**\n * Обчислює штраф для кожного нуля в матриці\n * @param {number[][]} matrix - Вхідна матриця\n * @return {number[][]} - Матриця штрафів\n */\nfunction calculatePenalties(matrix) {\n  const penalties = []; // масив для матриці штрафів\n\n  // Проходимося по кожному рядку матриці\n  for (let i = 0; i < matrix.length; i += 1) {\n    penalties[i] = []; // масив для рядка матриці штрафів\n\n    // Проходимося по кожному елементу у рядку\n    for (let j = 0; j < matrix[i].length; j += 1) {\n      // Якщо знаходимо нуль\n      if (matrix[i][j] === 0) {\n        // console.log('нуль');\n        penalties[i][j] = calculatePenaltyForRowAndColumn(matrix, i, j);\n      } else {\n        penalties[i][j] = null; // Штраф не обчислюється для не-нульових елементів\n      }\n    }\n  }\n\n  return penalties;\n}\n\n/**\n * Обчислює штраф для нуля у вказаному рядку та стовпці\n * @param {number[][]} matrix - Вхідна матриця\n * @param {number} row - Номер рядка\n * @param {number} column - Номер стовпця\n * @return {number} - Штраф для нуля\n */\nfunction calculatePenaltyForRowAndColumn(matrix, row, column) {\n  // Фільтруємо значення рядка, виключаючи поточний нуль та Infinity\n  const rowValues = matrix[row].filter(\n    (value, index) => index !== column && value !== Infinity\n  );\n\n  // Фільтруємо значення стовпця, виключаючи Infinity\n  const columnValues = matrix\n    .map(row => row[column])\n    .filter(value => value !== Infinity);\n\n  // Знаходимо мінімальне значення рядка, якщо є такі значення\n  const minRowValue = rowValues.length > 0 ? Math.min(...rowValues) : 0;\n\n  // Знаходимо мінімальне значення стовпця, якщо є такі значення\n  const minColumnValue =\n    columnValues.length > 0 ? Math.min(...columnValues) : 0;\n\n  // Повертаємо суму мінімальних значень рядка та стовпця\n  return minRowValue + minColumnValue;\n}\n\n// Приклад використання\nlet penaltiesMatrix = calculatePenalties(newMatrixCols);\nconsole.log('Матриця штрафів для нулів:', penaltiesMatrix);\n\n/**\n * ПОШУК МАКСИМАЛЬНОГО ШТРАФУ\n * @param {number[][]} penaltiesMatrix - Матриця штрафів\n * @return {object} - Об'єкт з максимальним штрафом та його координатами { value, row, column }\n */\nfunction findMaxPenalty(penaltiesMatrix) {\n  let maxValue = -Infinity; //  максимальне значення штрафу (на початку ініціалізуємо як нуль)\n  let maxRow = null; // номера рядка максимального штрафу\n  let maxColumn = null; // номера стовпця максимального штрафу\n\n  // Проходимося по кожному елементу матриці штрафів\n  for (let i = 0; i < penaltiesMatrix.length; i += 1) {\n    for (let j = 0; j < penaltiesMatrix[i].length; j += 1) {\n      // Якщо поточний штраф більший за максимальний\n      if (penaltiesMatrix[i][j] !== null && penaltiesMatrix[i][j] > maxValue) {\n        maxValue = penaltiesMatrix[i][j]; // Оновлюємо максимальне значення штрафу\n        maxRow = i; // Зберігаємо номер рядка поточного максимального штрафу\n        maxColumn = j; // Зберігаємо номер стовпця поточного максимального штрафу\n      } else if (\n        penaltiesMatrix[i][j] !== null &&\n        penaltiesMatrix[i][j] === maxValue\n      ) {\n        // Якщо є декілька максимальних значень, вибираємо той, де менше i та j\n        if (i < maxRow || (i === maxRow && j < maxColumn)) {\n          // Зберігаємо номер рядка та стовпця поточного максимального штрафу\n          maxRow = i;\n          maxColumn = j;\n        }\n      }\n    }\n  }\n\n  // координати задаються порядковим номером\n  return { value: maxValue, row: maxRow + 1, column: maxColumn + 1 };\n}\n\n// Приклад використання\nlet maxPenalty = findMaxPenalty(penaltiesMatrix);\nconsole.log('Максимальний штраф:', maxPenalty.value);\nconsole.log(`Координати: (${maxPenalty.row}, ${maxPenalty.column})`);\n\n/**\n * Заміна значень рядка та стовпця на Infinity\n * @param {number[][]} matrix - Вхідна матриця\n * @param {number} row - Номер рядка\n * @param {number} column - Номер стовпця\n * @return {number[][]} - Матриця зі зміненими значеннями\n */\nfunction replaceRowAndColumnWithInfinity(matrix, row, column) {\n  const newMatrix = matrix.map((r, i) =>\n    r.map((value, j) => (i === row || j === column ? Infinity : value))\n  );\n  return newMatrix;\n}\n\n// Приклад використання\nlet modifiedMatrix = replaceRowAndColumnWithInfinity(\n  newMatrixCols,\n  maxPenalty.row - 1,\n  maxPenalty.column - 1\n);\nconsole.log('Матриця після заміни на Infinity:', modifiedMatrix);\n\nfunction doOperations(modifiedMatrix, minBorder) {\n  console.log(subEveryRow(modifiedMatrix, minBorder));\n  console.log(subEveryColumn(modifiedMatrix, minBorder));\n}\n\ndoOperations(modifiedMatrix, newMinBorderCols);\n\n//// НЕГАМІЛЬТОНОВІ ЦИКЛИ\n/**\n * Предотвращение негамильтоновых контуров (циклов)\n * изменяет path\n * @param {number[][]} table\n * @param {number[]} path\n * @return {number[][]}\n */\nfunction preventCycle(table, path) {\n  console.log('Поиск циклов');\n  let paths = path.slice();\n  let pathCopy = path.slice();\n\n  for (let row = 0; row < paths.length; row++) {\n    let column = paths[row];\n\n    if (table[column][row] !== undefined) {\n      table[column][row] = Infinity;\n    }\n\n    for (let rowCopy = 0; rowCopy < pathCopy.length; rowCopy++) {\n      let columnCopy = pathCopy[rowCopy];\n\n      if (row === columnCopy) {\n        paths[rowCopy] = column;\n        paths.splice(row, 1);\n\n        if (table[rowCopy][column] !== undefined) {\n          table[rowCopy][column] = Infinity;\n        }\n        if (table[column][rowCopy] !== undefined) {\n          table[column][rowCopy] = Infinity;\n        }\n\n        console.log('Цикл найден. Уничтожен [' + rowCopy + '][' + column + ']');\n        return preventCycle(table, paths);\n      }\n    }\n  }\n\n  console.log('Цикл не найден');\n  return table;\n}\n\n//============ELSE ELSE ELSE==========================\n/**\n * Подсчитывает штрафы у нулей\n * Возвращает максимальное значение\n * и массив с координатами нулей и их штрафами\n * @return array\n */\n// function zeroDegreeMax(matrix) {\n//   console.log('Начало подсчета штрафов у нулей');\n//   let sumsArr = [];\n//   for (let i = 0; i < matrix.length; i += 1) {\n//     sumsArr[i] = [];\n//     for (let j = 0; j < matrix[i].length; j += 1) {\n//       if (matrix[i][j] === 0) {\n//         sumsArr[i][j] = sumMinRowColumn(matrix, i, j);\n//       }\n//     }\n//   }\n//   let str = 'Подсчитанные степени у нулей:';\n//   sumsArr.forEach((row, i) => {\n//     row.forEach((value, j) => {\n//       str += `<br>(${i}:${j})=${value}`;\n//     });\n//   });\n//   console.log(str);\n//   console.log('Конец подсчета штрафов у нулей');\n//   let max = sumsArr.map(row => Math.max(...row));\n//   console.log('Максимумы по строкам:' + max.join(' '));\n//   return [Math.max(...max), sumsArr];\n// }\n\n// /**\n//  * Подсчитывает штраф нуля с координатами row:column\n//  * @param {number} row\n//  * @param {number} column\n//  * @return {number}\n//  */\n// function sumMinRowColumn(matrix, row, column) {\n//   let rowArr = matrix[row];\n//   let columnArr = [];\n//   const columns = Object.keys(matrix[0]);\n\n//   for (let i = 0; i < matrix.length; i++) {\n//     if (i !== row) {\n//       columnArr.push(matrix[i][column]);\n//     }\n//   }\n\n//   delete rowArr[column];\n//   return Math.min(...rowArr) + Math.min(...columnArr);\n// }\n\n// console.log(zeroDegreeMax(newMatrixCols));\n\n//=======================================\n// function zeroDegreeMax(matrix) {\n//   const sumsArr = matrix.map((row, i) =>\n//     row.map((_, j) =>\n//       matrix[i][j] === 0 ? sumMinRowColumn(matrix, i, j) : undefined\n//     )\n//   );\n\n//   const max = sumsArr.map(row =>\n//     Math.max(...row.filter(val => val !== undefined))\n//   );\n//   return [Math.max(...max), sumsArr];\n// }\n\n// console.log(zeroDegreeMax(precedenceMatrix));\n\n// function zeroDegreePosition(matrix) {\n//   const [max, sumsArr] = zeroDegreeMax(matrix);\n//   const coords = [];\n//   sumsArr.forEach((row, i) =>\n//     row.forEach((value, j) => {\n//       if (value === max) {\n//         coords.push({ row: i, column: j });\n//       }\n//     })\n//   );\n//   return coords;\n// }\n\n// let zeroDegreePositions = zeroDegreePosition(precedenceMatrix);\n// console.log(\n//   `Максимальна степень 0 находятся на позициях ${zeroDegreePositions\n//     .map(coord => `(${coord.row},${coord.column})`)\n//     .join(' ')}`\n// );\n"],"names":["precedenceMatrix","minFromRows","matrix","row","minsByRows","subEveryRow","minBorder","mins","acc","curr","i","value","j","newMatrixRows","newMinBorderRows","minFromColumns","column","columnValues","minsByCols","subEveryColumn","newMatrixCols","newMinBorderCols","calculatePenalties","penalties","calculatePenaltyForRowAndColumn","rowValues","index","minRowValue","minColumnValue","penaltiesMatrix","findMaxPenalty","maxValue","maxRow","maxColumn","maxPenalty","replaceRowAndColumnWithInfinity","r","modifiedMatrix","doOperations"],"mappings":"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"}