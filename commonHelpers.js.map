{"version":3,"file":"commonHelpers.js","sources":["../src/js/algorithms/branchesAndBounds/matrixReduction.js","../src/js/algorithms/branchesAndBounds/penalties.js","../src/js/algorithms/branchesAndBounds/etapThree.js","../src/js/algorithms/branchesAndBounds/branchesAndBounds.js"],"sourcesContent":["// Знаходження мінімальних елементів по рядкам\nexport function minFromRows(matrix) {\n  return matrix.map(row => Math.min(...row));\n}\n\n// Віднімання мінімумів по рядках\nexport function subEveryRow(matrix, newMinBorderRows) {\n  const mins = minFromRows(matrix);\n  newMinBorderRows += mins.reduce((acc, curr) => acc + curr, 0);\n\n  const newMatrix = matrix.map((row, i) =>\n    row.map((value, j) => value - mins[i])\n  );\n\n  return { matrix: newMatrix, newMinBorderRows };\n}\n\n// Знаходження мінімальних елементів по стовпцях\nexport function minFromColumns(matrix) {\n  const mins = [];\n  const columns = Object.keys(matrix[0]);\n\n  columns.forEach(column => {\n    const columnValues = matrix.map(row => row[column]);\n    mins[column] = Math.min(...columnValues);\n  });\n\n  return mins;\n}\n\n// Віднімання мінімумів по стовпцях\nexport function subEveryColumn(matrix, newMinBorderCols) {\n  const mins = minFromColumns(matrix);\n  newMinBorderCols += Object.values(mins).reduce((acc, curr) => acc + curr, 0);\n\n  const newMatrix = matrix.map((row, i) =>\n    row.map((value, j) => value - mins[j])\n  );\n\n  return { matrix: newMatrix, newMinBorderCols };\n}\n","/**\n * Обчислює штраф для кожного нуля в матриці\n * @param {number[][]} matrix - Вхідна матриця\n * @return {number[][]} - Матриця штрафів\n */\nexport function calculatePenalties(matrix) {\n  const penalties = []; // масив для матриці штрафів\n\n  // Проходимося по кожному рядку матриці\n  for (let i = 0; i < matrix.length; i += 1) {\n    penalties[i] = []; // масив для рядка матриці штрафів\n\n    // Проходимося по кожному елементу у рядку\n    for (let j = 0; j < matrix[i].length; j += 1) {\n      // Якщо знаходимо нуль\n      if (matrix[i][j] === 0) {\n        // console.log('нуль');\n        penalties[i][j] = calculatePenaltyForRowAndColumn(matrix, i, j);\n      } else {\n        penalties[i][j] = null; // Штраф не обчислюється для не-нульових елементів\n      }\n    }\n  }\n\n  return penalties;\n}\n\n/**\n * Обчислює штраф для нуля у вказаному рядку та стовпці\n * @param {number[][]} matrix - Вхідна матриця\n * @param {number} row - Номер рядка\n * @param {number} column - Номер стовпця\n * @return {number} - Штраф для нуля\n */\nexport function calculatePenaltyForRowAndColumn(matrix, row, column) {\n  // Фільтруємо значення рядка, виключаючи поточний нуль та Infinity\n  const rowValues = matrix[row].filter(\n    (value, index) => index !== column && value !== Infinity\n  );\n\n  // Фільтруємо значення стовпця, виключаючи Infinity\n  const columnValues = matrix\n    .map(row => row[column])\n    .filter(value => value !== Infinity);\n\n  // Знаходимо мінімальне значення рядка, якщо є такі значення\n  const minRowValue = rowValues.length > 0 ? Math.min(...rowValues) : 0;\n\n  // Знаходимо мінімальне значення стовпця, якщо є такі значення\n  const minColumnValue =\n    columnValues.length > 0 ? Math.min(...columnValues) : 0;\n\n  // Повертаємо суму мінімальних значень рядка та стовпця\n  return minRowValue + minColumnValue;\n}\n\n/**\n * Знаходить максимальний штраф та ребро\n * @param {number[][]} penaltiesMatrix - Матриця штрафів\n * @return {object} - Об'єкт з максимальним штрафом та його координатами { value, row, column }\n */\n// Початковий масив для зберігання координат ребер\nexport let edgesArray = [];\n\nexport function findMaxPenalty(penaltiesMatrix) {\n  let maxValue = -Infinity; //  максимальне значення штрафу (на початку ініціалізуємо як нуль)\n  let maxRow = null; // номера рядка максимального штрафу\n  let maxColumn = null; // номера стовпця максимального штрафу\n\n  // Проходимося по кожному елементу матриці штрафів\n  for (let i = 0; i < penaltiesMatrix.length; i += 1) {\n    for (let j = 0; j < penaltiesMatrix[i].length; j += 1) {\n      // Якщо поточний штраф більший за максимальний\n      if (penaltiesMatrix[i][j] !== null && penaltiesMatrix[i][j] > maxValue) {\n        maxValue = penaltiesMatrix[i][j]; // Оновлюємо максимальне значення штрафу\n        maxRow = i; // Зберігаємо номер рядка поточного максимального штрафу\n        maxColumn = j; // Зберігаємо номер стовпця поточного максимального штрафу\n      } else if (\n        penaltiesMatrix[i][j] !== null &&\n        penaltiesMatrix[i][j] === maxValue\n      ) {\n        // Якщо є декілька максимальних значень, вибираємо той, де менше i та j\n        if (i < maxRow || (i === maxRow && j < maxColumn)) {\n          // Зберігаємо номер рядка та стовпця поточного максимального штрафу\n          maxRow = i;\n          maxColumn = j;\n        }\n      }\n    }\n  }\n\n  // Додаємо координати рядка та стовпця максимального штрафу до масиву ребер\n  edgesArray.push([maxRow + 1, maxColumn + 1]); // Додаємо координати рядка та стовпця (+1 для збігу з порядковим номером)\n\n  // координати задаються не індексом, а порядковим номером (+1)\n  return { value: maxValue, row: maxRow + 1, column: maxColumn + 1 };\n}\n","// Заміна значень рядка та стовпця на Infinity\nexport function replaceRowAndColumnWithInfinity(matrix, row, column) {\n  return matrix.map((r, i) =>\n    r.map((value, j) => (i === row - 1 || j === column - 1 ? Infinity : value))\n  );\n\n  // row - 1 -> оскільки беремо індекс, а не порядковий номер (maxPenalty.row = maxPenalty.index+1)\n}\n\nexport function preventCycles(matrix, edges) {\n  for (const [start, end] of edges) {\n    // Заборонити перехід між симетричними координатами\n    if (matrix[end - 1][start - 1] !== Infinity) {\n      matrix[end - 1][start - 1] = Infinity;\n      console.log(`Симетричний перехід (${end}, ${start}) заборонено`);\n    }\n\n    for (const [otherStart, otherEnd] of edges) {\n      if (\n        start !== otherStart &&\n        start !== otherEnd &&\n        end !== otherEnd &&\n        end !== otherStart\n      ) {\n        console.log(\n          'Знайдено цикл (координати не мають однакових значень)',\n          [start, end],\n          [otherStart, otherEnd]\n        );\n\n        const transitions = new Set([\n          [start, otherStart],\n          [start, otherEnd],\n          [end, otherStart],\n          [end, otherEnd],\n          [otherStart, start],\n          [otherStart, end],\n          [otherEnd, start],\n          [otherEnd, end],\n        ]);\n\n        for (const [vertex1, vertex2] of transitions) {\n          if (\n            !edges.some(edge => edge[0] === vertex1 && edge[1] === vertex2) &&\n            matrix[vertex1 - 1][vertex2 - 1] !== Infinity\n          ) {\n            matrix[vertex1 - 1][vertex2 - 1] = Infinity;\n            console.log(`Заборонено перехід (${vertex1}, ${vertex2})`);\n          }\n        }\n      }\n    }\n  }\n\n  return matrix;\n}\n\n// function doOperations(modifiedMatrix, minBorder) {\n//   console.log(subEveryRow(modifiedMatrix, minBorder));\n//   console.log(subEveryColumn(modifiedMatrix, minBorder));\n// }\n\n// doOperations(modifiedMatrix, newMinBorderCols);\n\n///////////////////////  NOTES\n// CASE-1. Not Bad ;))\n// function forbidNonHamiltonianCycles(matrix, edges) {\n//   for (let i = 0; i < edges.length; i += 1) {\n//     const start = edges[i][0];\n//     const end = edges[i][1];\n\n//     // Заборонити перехід між симетричними координатами\n//     if (matrix[end - 1][start - 1] !== Infinity) {\n//       matrix[end - 1][start - 1] = Infinity;\n//       console.log(\n//         `Симетричний перехід від вершини ${end} до вершини ${start} заборонено`\n//       );\n//     }\n\n//     for (let j = 0; j < edges.length; j += 1) {\n//       if (i !== j) {\n//         const otherStart = edges[j][0];\n//         const otherEnd = edges[j][1];\n\n//         if (\n//           start !== otherStart &&\n//           start !== otherEnd &&\n//           end !== otherEnd &&\n//           end !== otherStart\n//         ) {\n//           console.log(\n//             'Знайдено цикл (координати не мають однакових значень)',\n//             [start, end],\n//             [otherStart, otherEnd]\n//           );\n\n//           const transitions = [\n//             [start, otherStart],\n//             [start, otherEnd],\n//             [end, otherStart],\n//             [end, otherEnd],\n//             [otherStart, start],\n//             [otherStart, end],\n//             [otherEnd, start],\n//             [otherEnd, end],\n//           ];\n\n//           transitions.forEach(([vertex1, vertex2]) => {\n//             if (\n//               !edges.some(edge => edge[0] === vertex1 && edge[1] === vertex2)\n//             ) {\n//               matrix[vertex1 - 1][vertex2 - 1] = Infinity;\n//               console.log(\n//                 `Заборонено перехід від вершини ${vertex1} до вершини ${vertex2}`\n//               );\n//             }\n//           });\n//         }\n//       }\n//     }\n//   }\n\n//   return matrix;\n// }\n\n// CASE-2. REFERENCE\n// Заборона негамільтонових циклів\n// /**\n//  * Предотвращение негамильтоновых контуров (циклов)\n//  * Изменяет path\n//  * @param {number[][]} matrix - Вхідна матриця\n//  * @param {number[][]} path - Матриця шляхів\n//  * @return {number[][]} - Матриця зі зміненими значеннями\n//  */\n// export function preventCycle(matrix, path) {\n//   // console.log('Поиск циклов');\n//   let paths = path;\n//   let pathCopy = [...path];\n//   for (let row in paths) {\n//     let column = paths[row];\n//     if (matrix[column][row] !== undefined) {\n//       matrix[column][row] = Infinity;\n//     }\n//     for (let rowCopy in pathCopy) {\n//       let columnCopy = pathCopy[rowCopy];\n//       if (row === columnCopy) {\n//         paths[rowCopy] = column;\n//         delete paths[row];\n//         if (matrix[rowCopy][column] !== undefined) {\n//           matrix[rowCopy][column] = Infinity;\n//         }\n//         if (matrix[column][rowCopy] !== undefined) {\n//           matrix[column][rowCopy] = Infinity;\n//         }\n//         console.log(`Цикл найден. уничтожен [${rowCopy}][${column}]`);\n//         return preventCycle(matrix, paths);\n//       }\n//     }\n//   }\n//   console.log('Цикл не найден');\n//   return matrix;\n// }\n\n// CASE-3. PREVENT ONLY SYMMETRIC\n// function forbidNonHamiltonianCycles(matrix, edges) {\n//   // Перевіряємо кожне ребро з масиву ребер\n//   //   for (const [start, end] of edgesArray) {\n//   //     // Забороняємо перехід від start до end\n//   //     matrix[end - 1][start - 1] = Infinity;\n//   //     console.log(end - 1, start - 1);\n//   //   }\n\n//   for (let i = 0; i < edges.length; i += 1) {\n//     console.log(edges[i]);\n//     const start = edges[i][0];\n//     const end = edges[i][1];\n\n//     // Забороняємо перехід від start до end\n//     matrix[end - 1][start - 1] = Infinity;\n//   }\n\n//   //   return matrix;\n// }\n","// Pohorila Dariia\nimport * as taskGenerator from '../../generator/taskGenerator.js';\nimport * as matrixReduction from './matrixReduction.js';\nimport * as penalties from './penalties.js';\nimport * as etapThree from './etapThree.js';\n\n// let matrix = taskGenerator.generateMatrix(8, 15, 5);\n// console.table(matrix);\n\n// Матриця переналаштувань\nconsole.log('МАТРИЦЯ ПЕРЕНАЛАШТУВАНЬ');\nlet precedenceMatrix = [\n  [Infinity, 15, Infinity, 20, Infinity, 5, Infinity, 10],\n  [5, Infinity, 15, Infinity, 5, Infinity, 10, Infinity],\n  [Infinity, 20, Infinity, 15, Infinity, 5, Infinity, 5],\n  [10, Infinity, 20, Infinity, 5, Infinity, 10, Infinity],\n  [Infinity, 15, Infinity, 15, Infinity, 5, Infinity, 5],\n  [10, Infinity, 15, Infinity, 10, Infinity, 10, Infinity],\n  [Infinity, 20, Infinity, 20, Infinity, 10, Infinity, 5],\n  [5, Infinity, 15, Infinity, 5, Infinity, 5, Infinity],\n];\nconsole.table(precedenceMatrix);\n\n///// ЕТАП-1. ЗВЕДЕННЯ МАТРИЦІ\nconsole.log('ЕТАП-1. ЗВЕДЕННЯ МАТРИЦІ');\n// Знаходження мінімальних елементів по стовпцях\nlet minsByCols = matrixReduction.minFromColumns(precedenceMatrix);\nconsole.log('Мінімальні по стовпцях:', minsByCols.join(' '));\n\n// Віднімання мінімумів по стовпцях\nlet { matrix: newMatrixCols, newMinBorderCols } =\n  matrixReduction.subEveryColumn(precedenceMatrix, 0);\n\nprecedenceMatrix = newMatrixCols; // присвоїти початковій матриці нову\n\nconsole.log('Матриця після віднімання мінімумів по стовпцях:');\nconsole.table(newMatrixCols);\nconsole.log('Нова мінімальна границя:', newMinBorderCols);\n\n// Знайти мінімальні елементи по рядкам\nlet minsByRows = matrixReduction.minFromRows(precedenceMatrix);\nconsole.log('Мінімальні по рядкам:', minsByRows.join(' '));\n\n// Віднімання мінімумів по рядках\nlet { matrix: newMatrixRows, newMinBorderRows } = matrixReduction.subEveryRow(\n  precedenceMatrix,\n  newMinBorderCols\n);\n\nprecedenceMatrix = newMatrixRows; // присвоїти початковій матриці нову\n\nconsole.log('Матриця після віднімання мінімумів по рядках:');\nconsole.table(precedenceMatrix);\nconsole.log('Нова мінімальна границя:', newMinBorderRows);\n\n///// ЕТАП-2. ПОШУК ШТРАФІВ\n// Матриця штрафів\nconsole.log('ЕТАП-2. ОБЧИСЛЕННЯ ШТРАФІВ');\nlet penaltiesMatrix = penalties.calculatePenalties(precedenceMatrix);\nconsole.log('Матриця штрафів для нулів:');\nconsole.table(penaltiesMatrix);\n\n// Максимальний штраф та ребро\nlet maxPenalty = penalties.findMaxPenalty(penaltiesMatrix);\nconsole.log('Максимальний штраф:', maxPenalty.value);\nconsole.log(`Ребро: (${maxPenalty.row}, ${maxPenalty.column})`);\n\n// Масив знайдених ребер (додається автоматично в findMaxPenalty)\nlet edges = penalties.edgesArray;\n\n///// ЕТАП-3. ВИКЛЮЧЕННЯ РЕБРА\n/**\n * 1. В рядку і стовпчику знайденого ребра Infinity\n * 2. Заборона негамільтонових циклів\n */\n// Присвоюємо елементам рядка і стовпчика знайденого ребра значення Infinity\nprecedenceMatrix = etapThree.replaceRowAndColumnWithInfinity(\n  precedenceMatrix,\n  maxPenalty.row,\n  maxPenalty.column\n);\nconsole.log(\n  `Матриця після заміни ребра (${maxPenalty.row}, ${maxPenalty.column}) на Infinity: `\n);\nconsole.table(precedenceMatrix);\n\n// Заборонити негамільтонові цикли\nprecedenceMatrix = etapThree.preventCycles(precedenceMatrix, edges);\nconsole.table(precedenceMatrix);\n"],"names":["minFromRows","matrix","row","subEveryRow","newMinBorderRows","mins","acc","curr","i","value","j","minFromColumns","column","columnValues","subEveryColumn","newMinBorderCols","calculatePenalties","penalties","calculatePenaltyForRowAndColumn","rowValues","index","minRowValue","minColumnValue","edgesArray","findMaxPenalty","penaltiesMatrix","maxValue","maxRow","maxColumn","replaceRowAndColumnWithInfinity","r","preventCycles","edges","start","end","otherStart","otherEnd","transitions","vertex1","vertex2","edge","precedenceMatrix","minsByCols","matrixReduction.minFromColumns","newMatrixCols","matrixReduction.subEveryColumn","minsByRows","matrixReduction.minFromRows","newMatrixRows","matrixReduction.subEveryRow","penalties.calculatePenalties","maxPenalty","penalties.findMaxPenalty","penalties.edgesArray","etapThree.replaceRowAndColumnWithInfinity","etapThree.preventCycles"],"mappings":"ssBACO,SAASA,EAAYC,EAAQ,CAClC,OAAOA,EAAO,IAAIC,GAAO,KAAK,IAAI,GAAGA,CAAG,CAAC,CAC3C,CAGO,SAASC,EAAYF,EAAQG,EAAkB,CACpD,MAAMC,EAAOL,EAAYC,CAAM,EAC/B,OAAAG,GAAoBC,EAAK,OAAO,CAACC,EAAKC,IAASD,EAAMC,EAAM,CAAC,EAMrD,CAAE,OAJSN,EAAO,IAAI,CAACC,EAAKM,IACjCN,EAAI,IAAI,CAACO,EAAOC,IAAMD,EAAQJ,EAAKG,CAAC,CAAC,CACzC,EAE8B,iBAAAJ,EAC9B,CAGO,SAASO,EAAeV,EAAQ,CACrC,MAAMI,EAAO,CAAA,EAGb,OAFgB,OAAO,KAAKJ,EAAO,CAAC,CAAC,EAE7B,QAAQW,GAAU,CACxB,MAAMC,EAAeZ,EAAO,IAAIC,GAAOA,EAAIU,CAAM,CAAC,EAClDP,EAAKO,CAAM,EAAI,KAAK,IAAI,GAAGC,CAAY,CAC3C,CAAG,EAEMR,CACT,CAGO,SAASS,EAAeb,EAAQc,EAAkB,CACvD,MAAMV,EAAOM,EAAeV,CAAM,EAClC,OAAAc,GAAoB,OAAO,OAAOV,CAAI,EAAE,OAAO,CAACC,EAAKC,IAASD,EAAMC,EAAM,CAAC,EAMpE,CAAE,OAJSN,EAAO,IAAI,CAACC,EAAKM,IACjCN,EAAI,IAAI,CAACO,EAAOC,IAAMD,EAAQJ,EAAKK,CAAC,CAAC,CACzC,EAE8B,iBAAAK,EAC9B,CCnCO,SAASC,EAAmBf,EAAQ,CACzC,MAAMgB,EAAY,CAAA,EAGlB,QAAST,EAAI,EAAGA,EAAIP,EAAO,OAAQO,GAAK,EAAG,CACzCS,EAAUT,CAAC,EAAI,GAGf,QAASE,EAAI,EAAGA,EAAIT,EAAOO,CAAC,EAAE,OAAQE,GAAK,EAErCT,EAAOO,CAAC,EAAEE,CAAC,IAAM,EAEnBO,EAAUT,CAAC,EAAEE,CAAC,EAAIQ,EAAgCjB,EAAQO,EAAGE,CAAC,EAE9DO,EAAUT,CAAC,EAAEE,CAAC,EAAI,IAGvB,CAED,OAAOO,CACT,CASO,SAASC,EAAgCjB,EAAQC,EAAKU,EAAQ,CAEnE,MAAMO,EAAYlB,EAAOC,CAAG,EAAE,OAC5B,CAACO,EAAOW,IAAUA,IAAUR,GAAUH,IAAU,GACpD,EAGQI,EAAeZ,EAClB,IAAIC,GAAOA,EAAIU,CAAM,CAAC,EACtB,OAAOH,GAASA,IAAU,GAAQ,EAG/BY,EAAcF,EAAU,OAAS,EAAI,KAAK,IAAI,GAAGA,CAAS,EAAI,EAG9DG,EACJT,EAAa,OAAS,EAAI,KAAK,IAAI,GAAGA,CAAY,EAAI,EAGxD,OAAOQ,EAAcC,CACvB,CAQO,IAAIC,EAAa,CAAA,EAEjB,SAASC,EAAeC,EAAiB,CAC9C,IAAIC,EAAW,KACXC,EAAS,KACTC,EAAY,KAGhB,QAASpB,EAAI,EAAGA,EAAIiB,EAAgB,OAAQjB,GAAK,EAC/C,QAASE,EAAI,EAAGA,EAAIe,EAAgBjB,CAAC,EAAE,OAAQE,GAAK,EAE9Ce,EAAgBjB,CAAC,EAAEE,CAAC,IAAM,MAAQe,EAAgBjB,CAAC,EAAEE,CAAC,EAAIgB,GAC5DA,EAAWD,EAAgBjB,CAAC,EAAEE,CAAC,EAC/BiB,EAASnB,EACToB,EAAYlB,GAEZe,EAAgBjB,CAAC,EAAEE,CAAC,IAAM,MAC1Be,EAAgBjB,CAAC,EAAEE,CAAC,IAAMgB,IAGtBlB,EAAImB,GAAWnB,IAAMmB,GAAUjB,EAAIkB,KAErCD,EAASnB,EACToB,EAAYlB,GAOpB,OAAAa,EAAW,KAAK,CAACI,EAAS,EAAGC,EAAY,CAAC,CAAC,EAGpC,CAAE,MAAOF,EAAU,IAAKC,EAAS,EAAG,OAAQC,EAAY,EACjE,CC/FO,SAASC,EAAgC5B,EAAQC,EAAKU,EAAQ,CACnE,OAAOX,EAAO,IAAI,CAAC6B,EAAGtB,IACpBsB,EAAE,IAAI,CAACrB,EAAOC,IAAOF,IAAMN,EAAM,GAAKQ,IAAME,EAAS,EAAI,IAAWH,CAAM,CAC9E,CAGA,CAEO,SAASsB,EAAc9B,EAAQ+B,EAAO,CAC3C,SAAW,CAACC,EAAOC,CAAG,IAAKF,EAAO,CAE5B/B,EAAOiC,EAAM,CAAC,EAAED,EAAQ,CAAC,IAAM,MACjChC,EAAOiC,EAAM,CAAC,EAAED,EAAQ,CAAC,EAAI,IAC7B,QAAQ,IAAI,wBAAwBC,CAAG,KAAKD,CAAK,cAAc,GAGjE,SAAW,CAACE,EAAYC,CAAQ,IAAKJ,EACnC,GACEC,IAAUE,GACVF,IAAUG,GACVF,IAAQE,GACRF,IAAQC,EACR,CACA,QAAQ,IACN,wDACA,CAACF,EAAOC,CAAG,EACX,CAACC,EAAYC,CAAQ,CAC/B,EAEQ,MAAMC,EAAc,IAAI,IAAI,CAC1B,CAACJ,EAAOE,CAAU,EAClB,CAACF,EAAOG,CAAQ,EAChB,CAACF,EAAKC,CAAU,EAChB,CAACD,EAAKE,CAAQ,EACd,CAACD,EAAYF,CAAK,EAClB,CAACE,EAAYD,CAAG,EAChB,CAACE,EAAUH,CAAK,EAChB,CAACG,EAAUF,CAAG,CACxB,CAAS,EAED,SAAW,CAACI,EAASC,CAAO,IAAKF,EAE7B,CAACL,EAAM,KAAKQ,GAAQA,EAAK,CAAC,IAAMF,GAAWE,EAAK,CAAC,IAAMD,CAAO,GAC9DtC,EAAOqC,EAAU,CAAC,EAAEC,EAAU,CAAC,IAAM,MAErCtC,EAAOqC,EAAU,CAAC,EAAEC,EAAU,CAAC,EAAI,IACnC,QAAQ,IAAI,uBAAuBD,CAAO,KAAKC,CAAO,GAAG,EAG9D,CAEJ,CAED,OAAOtC,CACT,CC7CA,QAAQ,IAAI,yBAAyB,EACrC,IAAIwC,EAAmB,CACrB,CAAC,IAAU,GAAI,IAAU,GAAI,IAAU,EAAG,IAAU,EAAE,EACtD,CAAC,EAAG,IAAU,GAAI,IAAU,EAAG,IAAU,GAAI,GAAQ,EACrD,CAAC,IAAU,GAAI,IAAU,GAAI,IAAU,EAAG,IAAU,CAAC,EACrD,CAAC,GAAI,IAAU,GAAI,IAAU,EAAG,IAAU,GAAI,GAAQ,EACtD,CAAC,IAAU,GAAI,IAAU,GAAI,IAAU,EAAG,IAAU,CAAC,EACrD,CAAC,GAAI,IAAU,GAAI,IAAU,GAAI,IAAU,GAAI,GAAQ,EACvD,CAAC,IAAU,GAAI,IAAU,GAAI,IAAU,GAAI,IAAU,CAAC,EACtD,CAAC,EAAG,IAAU,GAAI,IAAU,EAAG,IAAU,EAAG,GAAQ,CACtD,EACA,QAAQ,MAAMA,CAAgB,EAG9B,QAAQ,IAAI,0BAA0B,EAEtC,IAAIC,EAAaC,EAA+BF,CAAgB,EAChE,QAAQ,IAAI,0BAA2BC,EAAW,KAAK,GAAG,CAAC,EAG3D,GAAI,CAAE,OAAQE,EAAe,iBAAA7B,CAAkB,EAC7C8B,EAA+BJ,EAAkB,CAAC,EAEpDA,EAAmBG,EAEnB,QAAQ,IAAI,iDAAiD,EAC7D,QAAQ,MAAMA,CAAa,EAC3B,QAAQ,IAAI,2BAA4B7B,CAAgB,EAGxD,IAAI+B,EAAaC,EAA4BN,CAAgB,EAC7D,QAAQ,IAAI,wBAAyBK,EAAW,KAAK,GAAG,CAAC,EAGzD,GAAI,CAAE,OAAQE,EAAe,iBAAA5C,CAAgB,EAAK6C,EAChDR,EACA1B,CACF,EAEA0B,EAAmBO,EAEnB,QAAQ,IAAI,+CAA+C,EAC3D,QAAQ,MAAMP,CAAgB,EAC9B,QAAQ,IAAI,2BAA4BrC,CAAgB,EAIxD,QAAQ,IAAI,4BAA4B,EACxC,IAAIqB,EAAkByB,EAA6BT,CAAgB,EACnE,QAAQ,IAAI,4BAA4B,EACxC,QAAQ,MAAMhB,CAAe,EAG7B,IAAI0B,EAAaC,EAAyB3B,CAAe,EACzD,QAAQ,IAAI,sBAAuB0B,EAAW,KAAK,EACnD,QAAQ,IAAI,WAAWA,EAAW,GAAG,KAAKA,EAAW,MAAM,GAAG,EAG9D,IAAInB,EAAQqB,EAQZZ,EAAmBa,EACjBb,EACAU,EAAW,IACXA,EAAW,MACb,EACA,QAAQ,IACN,+BAA+BA,EAAW,GAAG,KAAKA,EAAW,MAAM,iBACrE,EACA,QAAQ,MAAMV,CAAgB,EAG9BA,EAAmBc,EAAwBd,EAAkBT,CAAK,EAClE,QAAQ,MAAMS,CAAgB"}